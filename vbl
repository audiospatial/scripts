
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    Workspace = game:GetService("Workspace"),
    Lighting = game:GetService("Lighting"),
    CoreGui = game:GetService("CoreGui"),
    TeleportService = game:GetService("TeleportService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    UserInputService = game:GetService("UserInputService"),
    StarterGui = game:GetService("StarterGui")
}

-- Local Player & Camera
local LocalPlayer = Services.Players.LocalPlayer
local Camera = Services.Workspace.CurrentCamera

-- Auto-rejoin on error
Services.CoreGui.ChildAdded:Connect(function(child)
    if child:IsA("ScreenGui") and child.Name == "ErrorPrompt" then
        task.wait(2)
        Services.TeleportService:Teleport(game.PlaceId, LocalPlayer)
    end
end)

-- ============================
-- RAYFIELD UI LOADER
-- ============================
local Rayfield
do
    local success, loaded = pcall(function()
        return loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
    end)
    
    if success and loaded then
        Rayfield = loaded
    else
        warn("ZeckHub: Failed to load Rayfield UI.")
        return -- Stop execution if library fails
    end
end

-- ============================
-- MAIN WINDOW CREATION
-- ============================
local Window = Rayfield:CreateWindow({
    Name = "ZeckHub",
    LoadingTitle = "Loading ZeckHub...",
    LoadingSubtitle = "by Robertzeck",
    ConfigurationSaving = { Enabled = true, FileName = "zeckhub_config" },
    KeySystem = false,
    Theme = "Dark",
    ToggleUIKeybind = Enum.KeyCode.K
})

-- ============================
-- UPDATES TAB
-- ============================
local UpdatesTab = Window:CreateTab("Updates", "bell-dot")
UpdatesTab:CreateSection("Change Logs")
UpdatesTab:CreateParagraph({
    Title = "Updates",
    Content = "Code optimization and bug fixes. Visual section removed for better optimization."
})
UpdatesTab:CreateParagraph({
    Title = "Coming Soon",
    Content = "idk...lol"
})

-- ============================
-- GAME TAB (HITBOX BALL)
-- ============================
local GameTab = Window:CreateTab("Game", "flame")
GameTab:CreateSection("Hitbox Ball")

local CurrentHitboxScale = 5.0
local hitboxEnabled = true

-- Function to find any BasePart in model
local function findAnyPart(model)
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            return part
        end
    end
end

-- Create or update hitboxes
local function createOrUpdateHitboxes(scale)
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model.Name:match("^CLIENT_BALL_%d+$") then
            local ball = model:FindFirstChild("Ball.001")
            if not ball then
                local ref = findAnyPart(model)
                if ref then
                    ball = Instance.new("Part")
                    ball.Name = "Ball.001"
                    ball.Shape = Enum.PartType.Ball
                    ball.Size = Vector3.new(2, 2, 2) * scale
                    ball.CFrame = ref.CFrame
                    ball.Anchored = true
                    ball.CanCollide = false
                    ball.Transparency = 0.7
                    ball.Material = Enum.Material.ForceField
                    ball.Color = Color3.fromRGB(0, 255, 0)
                    ball.Parent = model
                end
            else
                ball.Size = Vector3.new(2, 2, 2) * scale
            end
        end
    end
end

-- Clear all hitboxes
local function clearHitboxes()
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model.Name:match("^CLIENT_BALL_%d+$") then
            local ball = model:FindFirstChild("Ball.001")
            if ball then
                ball:Destroy()
            end
        end
    end
end

-- Monitor new balls added to workspace
workspace.ChildAdded:Connect(function(child)
    if child:IsA("Model") and child.Name:match("^CLIENT_BALL_%d+$") then
        task.wait(0.1)
        if hitboxEnabled then
            createOrUpdateHitboxes(CurrentHitboxScale)
        end
    end
end)

-- Hitbox Size Slider
GameTab:CreateSlider({
    Name = "Hitbox Size",
    Range = {0, 20},
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = CurrentHitboxScale,
    Flag = "HitboxSize",
    Callback = function(val)
        CurrentHitboxScale = val
        if hitboxEnabled then
            createOrUpdateHitboxes(val)
        end
        Rayfield:Notify({
            Title = "Size Changed",
            Content = "Hitbox scale set to " .. val .. "x",
            Duration = 2,
            Image = "maximize"
        })
    end
})

-- Hitbox Toggle
GameTab:CreateToggle({
    Name = "Enable Hitboxes",
    CurrentValue = hitboxEnabled,
    Flag = "HitboxToggle",
    Callback = function(val)
        hitboxEnabled = val
        if val then
            createOrUpdateHitboxes(CurrentHitboxScale)
            Rayfield:Notify({
                Title = "Hitboxes Enabled",
                Content = "Ball hitboxes created",
                Duration = 2,
                Image = "check"
            })
        else
            clearHitboxes()
            Rayfield:Notify({
                Title = "Hitboxes Disabled",
                Content = "Ball hitboxes removed",
                Duration = 2,
                Image = "x"
            })
        end
    end
})

-- ============================
-- CHARACTER TAB
-- ============================
local CharTab = Window:CreateTab("Character", "user-round")
CharTab:CreateSection("Character Functions")

local humanoid, hrp
local directionalJumpEnabled = true
local moveInAirEnabled = false
local AirMoveSpeed = 50
local IsJumping = false

-- Setup character
local function setupCharacter(character)
    humanoid = character:WaitForChild("Humanoid")
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid.StateChanged:Connect(function(_, state)
        if state == Enum.HumanoidStateType.Freefall then
            -- Air movement handled in RenderStepped
        elseif state == Enum.HumanoidStateType.Landed then
            humanoid.AutoRotate = true
        end
    end)
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

-- Directional Jump
Services.UserInputService.JumpRequest:Connect(function()
    if directionalJumpEnabled and humanoid and hrp then
        task.defer(function()
            task.wait(0.03)
            local dir = Vector3.new(Camera.CFrame.LookVector.X, 0, Camera.CFrame.LookVector.Z)
            if dir.Magnitude > 0 then
                hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + dir.Unit)
                humanoid.AutoRotate = false
            end
        end)
    elseif humanoid then
        humanoid.AutoRotate = true
    end
end)

CharTab:CreateToggle({
    Name = "Directional Jump",
    CurrentValue = directionalJumpEnabled,
    Flag = "DirectionalJump",
    Callback = function(val)
        directionalJumpEnabled = val
        if not val and humanoid then
            humanoid.AutoRotate = true
        end
    end
})

CharTab:CreateParagraph({
    Title = "How to Use",
    Content = "Turn off shift-lock if enabled. Character will auto-steer to where you are looking."
})

CharTab:CreateToggle({
    Name = "Air Movement",
    CurrentValue = moveInAirEnabled,
    Flag = "AirMoveToggle",
    Callback = function(Value)
        moveInAirEnabled = Value
    end
})

CharTab:CreateSlider({
    Name = "Air Move Speed",
    Range = {10, 150},
    Increment = 5,
    Suffix = "studs/s",
    CurrentValue = AirMoveSpeed,
    Flag = "AirMoveSpeed",
    Callback = function(Value)
        AirMoveSpeed = Value
    end
})

-- Stepped check for jumping state
Services.RunService.Stepped:Connect(function()
    if humanoid then
        local state = humanoid:GetState()
        IsJumping = (state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall)
    end
end)

-- Air movement in RenderStepped
Services.RunService.RenderStepped:Connect(function()
    if moveInAirEnabled and IsJumping and humanoid and hrp then
        local moveDirection = humanoid.MoveDirection
        if moveDirection.Magnitude > 0 then
            hrp.Velocity = Vector3.new(
                moveDirection.X * AirMoveSpeed,
                hrp.Velocity.Y,
                moveDirection.Z * AirMoveSpeed
            )
        end
    end
end)

-- ============================
-- CLONE ESP SYSTEM
-- ============================
local CloneESP = {}
CloneESP.enabled = true
CloneESP.color = Color3.fromRGB(255, 255, 255)
CloneESP.espFolder = nil
CloneESP.clones = {}
CloneESP.renderConnection = nil

local validBodyParts = {
    Head = true, Torso = true, UpperTorso = true, LowerTorso = true,
    LeftArm = true, RightArm = true, LeftUpperArm = true, RightUpperArm = true,
    LeftLowerArm = true, RightLowerArm = true, LeftHand = true, RightHand = true,
    LeftLeg = true, RightLeg = true, LeftUpperLeg = true, RightUpperLeg = true,
    LeftLowerLeg = true, RightLowerLeg = true, LeftFoot = true, RightFoot = true,
    HumanoidRootPart = true
}
local ESP_DISTANCE = 5
local ESP_TRANSPARENCY = 0.3

-- Cleanup function
function CloneESP:Cleanup()
    if self.renderConnection then
        self.renderConnection:Disconnect()
        self.renderConnection = nil
    end
    if self.espFolder then
        self.espFolder:Destroy()
        self.espFolder = nil
    end
    self.clones = {}
end

-- Copy visual properties
function CloneESP:CopyVisualProperties(original, clone)
    clone.Material = original.Material
    clone.Transparency = original.Transparency + ESP_TRANSPARENCY
    clone.Color = self.color
    for _, child in ipairs(original:GetChildren()) do
        if child:IsA("Decal") or child:IsA("Texture") or child:IsA("SurfaceGui") then
            child:Clone().Parent = clone
        end
    end
end

-- Create ESP for character
function CloneESP:CreateESP(character)
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    self:Cleanup()
    self.espFolder = Instance.new("Folder")
    self.espFolder.Name = "ESP_Clones"
    self.espFolder.Parent = Camera

    for _, part in ipairs(character:GetChildren()) do
        if (part:IsA("Part") or part:IsA("MeshPart")) and validBodyParts[part.Name] then
            local clone = part:Clone()
            clone.Anchored = true
            clone.CanCollide = false
            clone.CanTouch = false
            clone.CanQuery = false
            clone.Parent = self.espFolder
            self:CopyVisualProperties(part, clone)
            for _, child in ipairs(clone:GetChildren()) do
                if child:IsA("Script") or child:IsA("LocalScript") or child:IsA("ModuleScript") or
                   child:IsA("Motor6D") or child:IsA("Weld") or child:IsA("WeldConstraint") or
                   child:IsA("Humanoid") or child:IsA("Attachment") then
                    child:Destroy()
                end
            end
            self.clones[part] = clone
        end
    end

    self.renderConnection = Services.RunService.RenderStepped:Connect(function()
        if not character or not character.Parent or not hrp then return end
        local camLook = Camera.CFrame.LookVector
        local horizontalLook = Vector3.new(camLook.X, 0, camLook.Z)
        if horizontalLook.Magnitude > 0 then
            horizontalLook = horizontalLook.Unit
        else
            horizontalLook = Vector3.new(0, 0, 1)
        end
        local espPos = hrp.Position - horizontalLook * ESP_DISTANCE
        local espCFrame = CFrame.new(espPos, espPos + horizontalLook)
        for originalPart, clone in pairs(self.clones) do
            if originalPart and originalPart:IsDescendantOf(character) and clone and clone.Parent then
                local success, relativeCFrame = pcall(function()
                    return hrp.CFrame:ToObjectSpace(originalPart.CFrame)
                end)
                if success then
                    clone.CFrame = espCFrame * relativeCFrame
                    clone.Color = self.color
                    clone.Material = originalPart.Material
                    clone.Transparency = originalPart.Transparency + ESP_TRANSPARENCY
                end
            end
        end
    end)
end

local function SetupCloneESP(character)
    if CloneESP.enabled then
        CloneESP:CreateESP(character)
    else
        CloneESP:Cleanup()
    end
end

CharTab:CreateToggle({
    Name = "Character ESP (Clone)",
    CurrentValue = true,
    Flag = "CloneESP_Toggle",
    Callback = function(value)
        CloneESP.enabled = value
        if value then
            if LocalPlayer.Character then
                SetupCloneESP(LocalPlayer.Character)
            end
        else
            CloneESP:Cleanup()
        end
    end
})

CharTab:CreateColorPicker({
    Name = "Clone ESP Color",
    Color = CloneESP.color,
    Flag = "CloneESP_Color",
    Callback = function(color)
        CloneESP.color = color
        for _, clone in pairs(CloneESP.clones) do
            if clone and clone:IsA("BasePart") then
                clone.Color = color
            end
        end
    end
})

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    SetupCloneESP(char)
end)
if LocalPlayer.Character then
    SetupCloneESP(LocalPlayer.Character)
end

-- ============================
-- HELPERS TAB
-- ============================
local LineTab = Window:CreateTab("Helpers", "eye")
LineTab:CreateSection("Directional Lines")

local lineDistance = 50
local maxLines = 6
local beams = {}
local linesEnabled = true
local colorList = {
    Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0),
    Color3.fromRGB(0, 0, 255), Color3.fromRGB(255, 165, 0),
    Color3.fromRGB(128, 0, 128), Color3.fromRGB(255, 255, 0),
    Color3.fromRGB(139, 0, 0), Color3.fromRGB(0, 100, 0)
}

-- Create beam for player
local function createBeamForPlayer(player, index)
    if beams[player] then return end
    local character = player.Character
    if not character then return end
    local head = character:FindFirstChild("Head")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not head or not hrp then return end

    local startAtt = Instance.new("Attachment", head)
    local targetPart = Instance.new("Part")
    targetPart.Anchored = true
    targetPart.CanCollide = false
    targetPart.Transparency = 1
    targetPart.Size = Vector3.new(0.1, 0.1, 0.1)
    targetPart.Parent = Services.Workspace
    local endAtt = Instance.new("Attachment", targetPart)

    local beam = Instance.new("Beam")
    beam.Attachment0 = startAtt
    beam.Attachment1 = endAtt
    beam.Width0 = 0.25
    beam.Width1 = 0.25
    beam.FaceCamera = true
    beam.LightEmission = 1
    beam.Transparency = NumberSequence.new(0.3)
    beam.Color = ColorSequence.new(colorList[(index - 1) % #colorList + 1])
    beam.Parent = head

    beams[player] = { beam = beam, target = targetPart, attachment = startAtt, active = true }
end

-- Hide/show line functions
local function hideLine(player)
    local data = beams[player]
    if data and data.beam then
        data.beam.Enabled = false
        if data.target then
            data.target.Transparency = 1
        end
        data.active = false
    end
end

local function showLine(player)
    local data = beams[player]
    if data and data.beam then
        data.beam.Enabled = true
        if data.target then
            data.target.Transparency = 1
        end
        data.active = true
    end
end

local function updateLinePosition(player)
    local character = player.Character
    if not character then return end
    local head = character:FindFirstChild("Head")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local data = beams[player]
    if head and hrp and data then
        data.target.Position = head.Position + hrp.CFrame.LookVector * lineDistance
    end
end

local function clearLine(player)
    local data = beams[player]
    if data then
        if data.beam then data.beam:Destroy() end
        if data.target then data.target:Destroy() end
        if data.attachment then data.attachment:Destroy() end
        beams[player] = nil
    end
end

-- Main line update loop
Services.RunService.RenderStepped:Connect(function()
    if not linesEnabled then
        for _, data in pairs(beams) do
            if data and data.beam then
                data.beam.Enabled = false
            end
        end
        return
    end
    local enemyPlayers = {}
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Team ~= LocalPlayer.Team then
            table.insert(enemyPlayers, player)
        end
    end
    for i = 1, #enemyPlayers do
        local player = enemyPlayers[i]
        if i <= maxLines then
            if not beams[player] then
                createBeamForPlayer(player, i)
            end
            showLine(player)
            updateLinePosition(player)
        else
            hideLine(player)
        end
    end
    for player, data in pairs(beams) do
        if not table.find(enemyPlayers, player) then
            hideLine(player)
        end
    end
end)

Services.Players.PlayerRemoving:Connect(function(player)
    clearLine(player)
end)

LineTab:CreateToggle({
    Name = "Enable Lines",
    CurrentValue = true,
    Callback = function(val)
        linesEnabled = val
        if not val then
            for player, data in pairs(beams) do
                hideLine(player)
            end
        end
    end
})

LineTab:CreateSlider({
    Name = "Line Distance",
    Range = {10, 100},
    Increment = 10,
    CurrentValue = lineDistance,
    Suffix = " studs",
    Callback = function(val)
        lineDistance = val
    end
})

-- ============================
-- AUTO TILT SYSTEM
-- ============================
local autoTiltEnabled = false
local hotkeyEnum = Enum.KeyCode.Z
local mobileButtonGui, mobileTiltButton, tiltToggleObject

local function notify(title, text)
    if not Services.UserInputService.TouchEnabled then
        pcall(function()
            Services.StarterGui:SetCore("SendNotification", {
                Title = title, Text = text, Duration = 3
            })
        end)
    end
end

local function applyTilt()
    if not autoTiltEnabled then return end
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
        local dir = Vector3.new(Camera.CFrame.LookVector.X, 0, Camera.CFrame.LookVector.Z)
        if dir.Magnitude > 0 then
            humanoid:Move(dir.Unit, false)
        end
    end
end

local function updateMobileButtonState()
    if mobileTiltButton then
        mobileTiltButton.Text = "Tilt: " .. (autoTiltEnabled and "ON" or "OFF")
    end
end

local function toggleAutoTilt(newValue)
    autoTiltEnabled = newValue
    updateMobileButtonState()
    if tiltToggleObject and tiltToggleObject.Toggle then
        tiltToggleObject.Toggle:Set(newValue)
    end
    if Services.UserInputService.TouchEnabled then
        if mobileButtonGui then
            mobileButtonGui.Enabled = true
            mobileTiltButton.Visible = newValue
        end
    end
    notify("Auto Tilt", newValue and "Enabled" or "Disabled")
end

local function createMobileTiltButton()
    if not Services.UserInputService.TouchEnabled then return end
    if mobileTiltButton then return end
    mobileButtonGui = Instance.new("ScreenGui")
    mobileButtonGui.Name = "TiltMobileButtonGui"
    mobileButtonGui.ResetOnSpawn = false
    mobileButtonGui.IgnoreGuiInset = true
    mobileButtonGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    mobileButtonGui.Parent = Services.CoreGui
    mobileTiltButton = Instance.new("TextButton")
    mobileTiltButton.Size = UDim2.new(0, 110, 0, 40)
    mobileTiltButton.Position = UDim2.new(1, -120, 1, -150)
    mobileTiltButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    mobileTiltButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    mobileTiltButton.Font = Enum.Font.GothamBold
    mobileTiltButton.TextSize = 14
    mobileTiltButton.Text = "Tilt: OFF"
    mobileTiltButton.Draggable = true
    mobileTiltButton.Parent = mobileButtonGui
    mobileTiltButton.MouseButton1Click:Connect(function()
        autoTiltEnabled = not autoTiltEnabled
        updateMobileButtonState()
        if tiltToggleObject and tiltToggleObject.Toggle then
            tiltToggleObject.Toggle:Set(autoTiltEnabled)
        end
        notify("Auto Tilt", autoTiltEnabled and "Enabled" or "Disabled")
    end)
    mobileTiltButton.Visible = false
end

createMobileTiltButton()

tiltToggleObject = LineTab:CreateToggle({
    Name = "Auto tilt (recommend for setters)",
    CurrentValue = false,
    Callback = function(val)
        toggleAutoTilt(val)
    end
})

LineTab:CreateInput({
    Name = "Key toggle (PC)",
    CurrentValue = "",
    PlaceholderText = "Ex: Z",
    RemoveTextAfterFocusLost = true,
    Flag = "TiltKeyInput",
    Callback = function(text)
        text = text:upper()
        local key = Enum.KeyCode[text]
        if key then
            hotkeyEnum = key
            notify("Key", "New toggle key: " .. text)
        else
            notify("Error", "Unavailable key: " .. text)
        end
    end
})

Services.UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == hotkeyEnum then
        toggleAutoTilt(not autoTiltEnabled)
    end
end)

Services.RunService.RenderStepped:Connect(applyTilt)

LineTab:CreateParagraph({
    Title = "How to use",
    Content = "If you have experience as a setter it will be easy here the inclination is applied to where you look without having to use the joystick or the w on pc."
})

-- ============================
-- ENEMY JUMP ESP
-- ============================
local enemyJumpESPEnabled = true
local jumpESPGuiStorage = {}
local connections = {}

local function isEnemy(player)
    return player ~= LocalPlayer and player.Team and LocalPlayer.Team and player.Team ~= LocalPlayer.Team
end

local function createESP(player)
    if not player.Character or jumpESPGuiStorage[player] then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "JumpESP"
    highlight.Adornee = player.Character
    highlight.FillTransparency = 1
    highlight.OutlineTransparency = 0
    highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = player.Character
    jumpESPGuiStorage[player] = highlight
end

local function removeESP(player)
    if jumpESPGuiStorage[player] then
        jumpESPGuiStorage[player]:Destroy()
        jumpESPGuiStorage[player] = nil
    end
end

local function disconnectESP(player)
    if connections[player] then
        for _, conn in pairs(connections[player]) do
            pcall(function() conn:Disconnect() end)
        end
        connections[player] = nil
    end
    removeESP(player)
end

local function setupJumpESP(player)
    if player == LocalPlayer then return end
    local function monitorJump(character)
        disconnectESP(player)
        local humanoid = character:WaitForChild("Humanoid", 3)
        local head = character:FindFirstChild("Head")
        if not humanoid or not head then return end
        local stateConn = humanoid.StateChanged:Connect(function(_, newState)
            if not enemyJumpESPEnabled then return end
            if isEnemy(player) then
                if newState == Enum.HumanoidStateType.Jumping or newState == Enum.HumanoidStateType.Freefall then
                    createESP(player)
                elseif newState == Enum.HumanoidStateType.Landed then
                    removeESP(player)
                end
            else
                removeESP(player)
            end
        end)
        local heartbeatConn = Services.RunService.Heartbeat:Connect(function()
            if not player.Character or not isEnemy(player) then
                removeESP(player)
            else
                local state = humanoid:GetState()
                if state ~= Enum.HumanoidStateType.Jumping and state ~= Enum.HumanoidStateType.Freefall then
                    removeESP(player)
                end
            end
        end)
        connections[player] = { stateConn, heartbeatConn }
    end
    if player.Character then
        monitorJump(player.Character)
    end
    player.CharacterAdded:Connect(monitorJump)
end

for _, p in ipairs(Services.Players:GetPlayers()) do
    setupJumpESP(p)
end
Services.Players.PlayerAdded:Connect(setupJumpESP)

LineTab:CreateToggle({
    Name = "Enemy Jump ESP",
    CurrentValue = true,
    Callback = function(val)
        enemyJumpESPEnabled = val
        if not val then
            for player in pairs(jumpESPGuiStorage) do
                removeESP(player)
            end
        end
    end
})

-- ============================
-- OTHERS TAB
-- ============================
local OthersTab = Window:CreateTab("Others", "alert-triangle")
OthersTab:CreateSection("Utility Functions")

-- Rejoin function
local function rejoin()
    Services.TeleportService:Teleport(game.PlaceId, LocalPlayer)
end

OthersTab:CreateButton({
    Name = "Rejoin Server",
    Callback = rejoin
})

OthersTab:CreateButton({
    Name = "Panic Mode (Disable All)",
    Callback = function()
        -- Disable all features
        hitboxEnabled = false
        clearHitboxes()
        directionalJumpEnabled = false
        moveInAirEnabled = false
        linesEnabled = false
        CloneESP.enabled = false
        CloneESP:Cleanup()
        autoTiltEnabled = false
        enemyJumpESPEnabled = false
        for player in pairs(beams) do
            clearLine(player)
        end
        for player in pairs(jumpESPGuiStorage) do
            removeESP(player)
        end
        Rayfield:Notify({
            Title = "Panic Mode Activated",
            Content = "All features disabled.",
            Duration = 3,
            Image = "skull"
        })
    end
})

-- ============================
-- FINAL INITIALIZATION
-- ============================
Rayfield:Notify({
    Title = "ZeckHub Loaded Successfully",
    Content = "Script activated. Press K to toggle interface.",
    Duration = 5,
    Image = "check"
})

-- github.com/bb16268
